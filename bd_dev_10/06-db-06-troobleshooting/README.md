## Домашнее задание к занятию 6. «Troubleshooting»  

### Задача 1  
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.  
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать.  
Вы как инженер поддержки решили произвести эту операцию:  
напишите список операций, которые вы будете производить для остановки запроса пользователя;  
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.  

#### Ответ:  
Напишите список операций, которые вы будете производить для остановки запроса пользователя  
Найдем все операции, выполняющиеся более 3 минут.
```
db.currentOp().inprog.forEach(
  function(op) {
    if(op.secs_running > 180) printjson(op);
  }
)
```
Завершим все операции по их opid
```
db.killOp(<opid>)
```
Предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
- Разобраться с самим запросом.  
- Методом maxTimeMS() задать лимит выполнения операции.  


### Задача 2  
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.  
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.  
При масштабировании сервиса до N реплик вы увидели, что:  
сначала происходит рост отношения записанных значений к истекшим,  
Redis блокирует операции записи.  
Как вы думаете, в чём может быть проблема?  

#### Ответ:  
Чаще бывают проблемы с нехваткой памяти. Но так же могут быть и проблемы сетевой связанности нод.  

#### Доработка:  
Во 2 задании прошу изучить статью redis.io...n/latency/ (Latency generated by expires) и описать подробно почему Redis блокирует запись.  
Ответ может быть вот в этом разделе:   
```
Latency generated by expires
Redis evict expired keys in two ways:

One lazy way expires a key when it is requested by a command, but it is found to be already expired.
One active way expires a few keys every 100 milliseconds.
The active expiring is designed to be adaptive. An expire cycle is started every 100 milliseconds (10 times per second), and will do the following:

Sample ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP keys, evicting all the keys already expired.
If the more than 25% of the keys were found expired, repeat.
```
Вывод дающийся в данном разделе:  
```
if the database has many, many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.
```
Так как отношение кол-ва записанных ключей к истекших увеличивается пропорционально репликам, то такое поведение системы нормально, т.к. система старается не допустить использования большого кол-ва памяти для истекших ключей.  

### Задача 3  
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:  
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '  
Как вы думаете, почему это начало происходить и как локализовать проблему?  
Какие пути решения этой проблемы вы можете предложить?  

#### Ответ:  
Такая проблема связана с увеличением времени обработки запроса. Т.к. количество записей росло, то скорее всего перестало хватать производительности.  
- Создать индексы для ускорения и оптимизации запросов.  
- Увеличить параметры таймаутов. connect_timeout, interactive_timeout, wait_timeout  
- Оптимизировать сами запросы.  
- Наконец просто увеличить ресурсы хоста с базой данных.  

### Задача 4  
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.  
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:  
postmaster invoked oom-killer  
Как вы думаете, что происходит?  
Как бы вы решили эту проблему?  

#### Ответ:  
Это явно указывает на недостаток оперативной памяти.  
- Необходимо внимательно пересмотреть все настройки по выделению памяти в postgress. Так же убедится в отсутствии конкуренции за память со стороны других приложений на сервере.  
- Можно еще добавить vm.overcommit_memory = 2 чтобы отказать в обработке запросам, запрашивающих память, размер которой превышает суммарный размер памяти пространства подкачки и ОЗУ.  

Доработка:  
- Увеличить объём swap - что может негативно сказаться на производительности  
- Обратить внимание на параметры напрямую связанные с использованием оперативной памяти хоста. Такие параметры как shared_buffer, effective_cache_size. Настроить эти параметры так, чтобы система не пыталась выйти за пределы достпной на сервере оперативной памяти  
- 
